# 常见排序算法简介
## 目录
* [插入排序](#插入排序)
    * [直接插入排序](#直接插入排序)
    * [希尔排序](#希尔排序)
* [交换排序](#交换排序)
    * [冒泡排序](#冒泡排序)
    * [快速排序](#快速排序)
* [选择排序](#选择排序)
    * [直接选择排序](#直接选择排序)
    * [堆排序](#堆排序)
* [归并排序](#归并排序)
* [基数排序](#基数排序)
* [总结](#总结)

## 插入排序
__`依次将无序列表中的一个记录，按照关键字的大小插入到已排好序的一个子序列中的适当位置，知道所有的记录都插入为止。`__
### 直接插入排序
#### 直接插入排序（Straight Insertion Sort）基本思想：
`每次将一个待排序的数据元素，插入到前面已经排好序的数列中的适当位置，使数列依然有序；直到待排序数据元素全部插入完为止。`
#### 具体做法：
将待插入记录R[i]从右向左依次与有序列表中记录R[j]进行比较：
1. 若R[j]大于R[i]，则将R[j]后移一个位置;
2. 若R[j]小于等于R[i]，则查找过程结束，j+1即为R[i]的插入位置。(原j+1及其之后所有记录已经全部后移了一个位置)
#### 哨兵
1. 保存上次插入记录R[i]的副本；
2. 当前插入记录与上次插入记录比较，若小于上次记录值，则则将上次记录R[i]及其之后所有记录后一一个位置，上次插入的位置作为本次插入的起点。反之，仍然从最后一个位置从右向左依次比较。


### 希尔排序
#### 希尔排序(Shell's Sort)基本思想：
`先取一个小于n的整数d(1)作为第一个增量，把文件的全部记录分组。所有距离为d(1)的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d(2)<d(1)重复上述的分组和排序，直至所取的增量d(n)=1，即所有记录放在同一组中进行直接插入排序为止。`
> 希尔排序的时间性能优于直接插入排序 
## 交换排序
### 冒泡排序
#### 冒泡排序（Bubble Sort）具体做法：
1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。
### 快速排序
>快速排序（Quicksort）是对冒泡排序的一种改进。
#### 快速排序（Quicksort）基本思想：
`通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。`
#### 具体做法
&emsp;设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，这个过程称为`一趟快速排序`。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。
##### 一趟快速排序的算法是：
1. 设置两个变量i、j，排序开始的时候：i=0，j=N-1；
2. 以第一个数组元素作为关键数据，赋值给key，即key=A[0]；
3. 从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]的值交换；
4. 从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]的值交换；
5. 重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。

## 选择排序
### 直接选择排序
#### 直接选择排序(Straight Select Sorting) 基本思想：
`第一次从R[0]~R[n-1]中选取最小值，与R[0]交换，第二次从R[1]~R[n-1]中选取最小值，与R[1]交换，....，第i次从R[i-1]~R[n-1]中选取最小值，与R[i-1]交换，.....，第n-1次从R[n-2]~R[n-1]中选取最小值，与R[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。`
### 堆排序
#### 简介
&emsp;`堆排序（Heapsort）`是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。<br>
&emsp;在堆的数据结构中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点）。堆中定义以下几种操作：<br>

* 最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点
* 创建最大堆（Build Max Heap）：将堆中的所有数据重新排序
* 堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算

## 归并排序
#### 简介
&emsp;`归并排序（MERGE-SORT）`是建立在`归并操作`上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。
#### 归并操作
1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针超出序列尾
5. 将另一序列剩下的所有元素直接复制到合并序列尾
#### 归并排序
1. 将序列每相邻两个数字进行归并操作（merge)，形成floor(n/2+n%2)个序列，排序后每个序列包含两个元素
2. 将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素
3. 重复步骤2，直到所有元素排序完毕

## 基数排序
#### 基本思想
1. 根据数据项个位上的值，把所有的数据项分为10组；
2. 然后对这10组数据重新排列：把所有以0结尾的数据排在最前面，然后是结尾是1的数据项，照此顺序直到以9结尾的数据，这个步骤称为第一趟子排序；
3. 在第二趟子排序中，再次把所有的数据项分为10组，但是这一次是根据数据项十位上的值来分组的。这次分组不能改变先前的排序顺序。也就是说，第二趟排序之后，从每一组数据项的内部来看，数据项的顺序保持不变；
4. 然后再把10组数据项重新合并，排在最前面的是十位上为0的数据项，然后是10位为1的数据项，如此排序直到十位上为9的数据项。
5. 对剩余位重复这个过程，如果某些数据项的位数少于其他数据项，那么认为它们的高位为0。
#### 示例
* 初始关键字     421 240 035 532 305 430 124
* 第一趟排序后[240 430] [421] [532] [124] [035 305]    ——(个位数排序)
* 第二趟排序后(305) (421 124) (430 532 035) (240)      ——(十位数排序)
* 最后排序结果(035) (124) (240) (305) (421 430) (532)  ——(百位数排序)

## 总结

<table>
    <tr>
        <th rowspan="2">类别</th>
        <th rowspan="2">方法</th>
        <th rowspan="1" colspan="3">时间复杂度</th>
        <th rowspan="2">空间复杂度</th>
        <th rowspan="2">稳定性</th>
    </tr>
    <tr>
        <td>平均</td>
        <td>最好</td>
        <td>最坏</td>
    </tr>
    <tr>
        <td rowspan="2">插入排序</td>
        <td>直接插入排序</td>
        <td>O(n<sup>2</sup>)</td>
        <td>O(n)</td>
        <td>O(n<sup>2</sup>)</td>
        <td>O(1)</td>
        <td>稳定</td>
    </tr>
    <tr>
        <td>希尔排序</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>O(1)</td>
        <td>不稳定</td>
    </tr>
    <tr>
        <td rowspan="2">选择排序</td>
        <td>直接选择排序</td>
        <td>O(n<sup>2</sup>)</td>
        <td>O(n<sup>2</sup>)</td>
        <td>O(n<sup>2</sup>)</td>
        <td>O(1)</td>
        <td>不稳定</td>
    </tr>
    <tr>
        <td>堆排序</td>
        <td>O(nlog<sub>2</sub>n)</td>
        <td>O(nlog<sub>2</sub>n)</td>
        <td>O(nlog<sub>2</sub>n)</td>
        <td>O(1)</td>
        <td>不稳定</td>
    </tr>
    <tr>
        <td rowspan="2">交换排序</td>
        <td>冒泡排序</td>
        <td>O(n<sup>2</sup>)</td>
        <td>O(n<sup>2</sup>)</td>
        <td>O(n<sup>2</sup>)</td>
        <td>O(1)</td>
        <td>稳定</td>
    </tr>
    <tr>
        <td>快速排序</td>
        <td>O(nlog<sub>2</sub>n)</td>
        <td>O(nlog<sub>2</sub>n)</td>
        <td>O(n<sup>2</sup>)</td>
        <td>O(n)或O(log<sub>2</sub>n)</td>
        <td>不稳定</td>
    </tr>
    <tr>
        <td colspan="2" style="text-align:center">归并排序</td>
        <td>O(nlog<sub>2</sub>n)</td>
        <td>O(nlog<sub>2</sub>n)</td>
        <td>O(nlog<sub>2</sub>n)</td>
        <td>O(n)</td>
        <td>稳定</td>
    </tr>
    <tr>
        <td colspan="2" style="text-align:center">基数排序</td>
        <td>O(nd)</td>
        <td>O(nd)</td>
        <td>O(nd)</td>
        <td>O(r+n)</td>
        <td>稳定</td>
    </tr>
    <tfoot>
        <tr>
            <td colspan="7" style="text-align:center">n为数据规模。基数排序中r为基数，表示r进制，d为位数</td>
        </tr>
    </tfoot>
</table>

### 适用场景 
1. 若n较小(如n≤50)，可采用直接插入或直接选择排序。当记录规模较小时，直接插入排序较好，否则因为直接选择移动的记录数少于直接插人，应选直接选择排序为宜。
2. 若序列初始状态基本有序，则直接插入和冒泡最佳，随机的快速排序也不错。插入排序对部分有序的数组很有效，所需的比较次数平均只有选择排序的一半。
3. 若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。

    * 快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；
    * 堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。但这两种排序都是不稳定的。
    * 若要求排序稳定，则可选用归并排序。两两归并的排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。先利用直接插入排序求得较长的有序子文件，然后再两两归并之。因为直接插入排序是稳定的，所以改进后的归并排序仍是稳定的。

4. 希尔排序比插入排序和选择排序要快得多，并且数组越大，优势越大。如果需要解决一个排序问题而又没有系统排序函数可用（例如直接接触硬件或者运行于嵌入式系统中的代码），可以先用希尔排序，再考虑是否替换为更复杂的排序算法。而对于部分有序和小规模的数组，应使用插入排序。
5. 归并排序可以处理数百万甚至更大规模的数组，但是插入排序和选择排序做不到。归并排序的主要缺点是辅助数组所使用的额外空间和n的大小成正比。
6. 快速排序的优点是原地排序（只需要一个很小的辅助栈），但是基准的选取是个问题，对于小数组，快速排序要比插入排序慢。
7. 堆排序的优点是在排序时可以将需要排序的数组本身作为堆，无需任何额外空间，与选择排序有些类似，但所需的比较要少得多，堆排序适合例如嵌入式系统或低成本移动设备中容量有限的场景。




## 参考
1. https://www.nowcoder.com/discuss/200097?type=1
2. https://www.cnblogs.com/angelye/p/7508292.html